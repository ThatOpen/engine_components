import * as OBC from "@thatopen/components";
import * as THREE from "three";
import * as FRAGS from "@thatopen/fragments";

/**
 * Mesher is a class that manages the creation and removal of THREE.Mesh objects from fragment data. It allows to efficiently retrieve and remove meshes for specific model items. ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/Mesher).
 */
export class Mesher extends OBC.Component implements OBC.Disposable {
  static uuid = "ab45d0a7-feea-4afc-927c-80832dae76dd" as const;
  enabled = true;

  /**
   * A map of model IDs to arrays of THREE.BufferGeometry objects.
   * This is used to store and reuse the geometries generated by the mesher.
   */
  readonly geometries: OBC.ModelIdDataMap<
    { geometry: THREE.BufferGeometry; transform: THREE.Matrix4 }[]
  > = new FRAGS.DataMap();

  /**
   * Retrieves meshes for specified model items, optionally applying a material and coordinate system transformation.
   *
   * @param modelIdMap - A map of model IDs to an array of local IDs, specifying which items to retrieve meshes for.
   * @param _config - Optional configuration object.
   * @param _config.material - Optional material to apply to the meshes. If not provided, the default material is used.
   * @param _config.coordinate - Whether to apply coordinate system transformation. Defaults to `true`.
   * @param _config.applyTransformation - Whether to bring the mesh to its original position or leave it at 0,0,0. Defaults to `true`.
   * @returns A map of model IDs to a map of local IDs to an array of THREE.Mesh objects.
   */
  async get(
    modelIdMap: OBC.ModelIdMap,
    _config?: {
      material?: THREE.Material;
      coordinate?: boolean;
      applyTransformation?: boolean;
    },
  ) {
    const { material, coordinate, applyTransformation } = {
      coordinate: true,
      applyTransformation: true,
      ..._config,
    };
    const fragments = this.components.get(OBC.FragmentsManager);
    const result: OBC.ModelIdDataMap<THREE.Mesh[]> = new FRAGS.DataMap();
    for (const [modelId, localIds] of Object.entries(modelIdMap)) {
      const model = fragments.list.get(modelId);
      if (!model) continue;
      const modelGeometries = this.getModelMeshes(modelId);
      for (const localId of localIds) {
        let modelMeshes = result.get(modelId);
        if (!modelMeshes) {
          modelMeshes = new FRAGS.DataMap();
          result.set(modelId, modelMeshes);
        }
        let itemGeometries = modelGeometries.get(localId);
        if (itemGeometries && itemGeometries.length > 0) {
          const meshes: THREE.Mesh[] = [];
          for (const [_, { geometry, transform }] of itemGeometries.entries()) {
            const mesh = await this.createMesh(model, geometry, transform, {
              material,
              applyTransformation,
              coordinate,
            });
            meshes.push(mesh);
          }
          modelMeshes.set(localId, meshes);
          continue;
        } else {
          itemGeometries = [];
          modelGeometries.set(localId, itemGeometries);
        }
        const [meshData] = await model.getItemsGeometry([localId]);
        if (!meshData) continue; // TODO: investigate why it is undefined sometimes
        const itemMeshes: THREE.Mesh[] = [];
        for (const data of meshData) {
          const geometryData = this.createGeometry(data);
          if (!geometryData) continue;
          const { geometry, transform } = geometryData;
          itemGeometries.push(geometryData);
          const mesh = await this.createMesh(model, geometry, transform, {
            material,
            applyTransformation,
            coordinate,
          });
          itemMeshes.push(mesh);
        }
        modelMeshes.set(localId, itemMeshes);
      }
    }
    return result;
  }

  private getModelMeshes(modelId: string) {
    let modelMeshes = this.geometries.get(modelId);
    if (!modelMeshes) {
      modelMeshes = new FRAGS.DataMap();
      this.geometries.set(modelId, modelMeshes);
    }
    return modelMeshes;
  }

  /**
   * Removes the cached geometries by disposing the resources.
   * This makes the meshes created by the component unusable as the geometry will no longer be present.
   *
   * @param modelIds - An optional array of model IDs to remove. If not provided, all meshes will be removed.
   */
  remove(modelIds = [...this.geometries.keys()]) {
    for (const modelId of modelIds) {
      const geometries = this.geometries.get(modelId);
      if (!geometries) continue;
      for (const [_, geometryList] of geometries) {
        for (const { geometry } of geometryList) {
          geometry.dispose();
        }
      }
      this.geometries.delete(modelId);
    }
  }

  readonly onDisposed = new OBC.Event();

  dispose(full = true) {
    this.remove();
    if (full) this.geometries.dispose();
    this.onDisposed.trigger(Mesher.uuid);
  }

  getMeshesFromResult(result: OBC.ModelIdDataMap<THREE.Mesh[]>) {
    const meshes: THREE.Mesh[] = [];
    for (const modelMeshes of result.values()) {
      for (const itemMeshes of modelMeshes.values()) {
        meshes.push(...itemMeshes);
      }
    }
    return meshes;
  }

  private createGeometry(data: FRAGS.MeshData) {
    const { positions, indices, normals, transform } = data;
    if (!(positions && indices && normals)) return null;
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute(
      "normal",
      new THREE.BufferAttribute(normals, 3, true),
    );
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    return { geometry, transform };
  }

  private async createMesh(
    model: FRAGS.FragmentsModel,
    geometry: THREE.BufferGeometry,
    transform: THREE.Matrix4,
    _config?: {
      material?: THREE.Material;
      applyTransformation?: boolean;
      coordinate?: boolean;
    },
  ) {
    const { material, applyTransformation, coordinate } = {
      applyTransformation: true,
      coordinate: true,
      ..._config,
    };
    const fragments = this.components.get(OBC.FragmentsManager);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.applyMatrix4(transform);
    if (!applyTransformation) mesh.position.set(0, 0, 0);
    if (coordinate && fragments.baseCoordinationModel !== model.modelId) {
      const matrix = await model.getCoordinationMatrix();
      fragments.applyBaseCoordinateSystem(mesh, matrix);
    }
    return mesh;
  }
}
