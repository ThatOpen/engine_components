var y=Object.defineProperty;var w=(a,n,t)=>n in a?y(a,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[n]=t;var o=(a,n,t)=>(w(a,typeof n!="symbol"?n+"":n,t),t);import{c as b,E as P,M as c,F as m,D as v}from"./graphic-vertex-picker-DIM7gQA5.js";import{W as C,m as R,d as k,n as S,F as E}from"./index-BVinSk0X.js";import{H as p}from"./index-DTBV6yJD.js";import{M as F}from"./index-uVKS97J8.js";const h=class h extends b{constructor(t){super(t);o(this,"_world");o(this,"styles",new C);o(this,"outlinePositions",!1);o(this,"_mesh",null);o(this,"onDisposed",new P);o(this,"_meshes",[]);o(this,"_map",{});o(this,"_activeStyles",new Set);o(this,"_styleCallbacks",{});t.add(h.uuid,this),this.setupEvents()}set world(t){if(this._world=t,!t)return;this.getRenderer().postproduction.excludedObjectsPass.addExcludedMaterial(this._points.material)}get world(){return this._world}get _points(){return this._mesh||(this._mesh=new R(new k,new S({size:10,sizeAttenuation:!1,depthTest:!1}))),this._mesh}get enabled(){return!this.world||this.world.isDisposing?!1:this.getRenderer().postproduction.outlinesEnabled}set enabled(t){if(!this.world||this.world.isDisposing)return;const e=this.getRenderer();e.postproduction.outlinesEnabled=t,this.outlinePositions&&(this._points.material.color=this.color,this.world.scene.three.add(this._points))}get color(){return this.getRenderer().postproduction.outlinePass.outlineColor}set color(t){this.getRenderer().postproduction.outlinePass.outlineColor.copy(t),this._points.material.color.copy(t)}get thickness(){return this.getRenderer().postproduction.outlinePass.thickness}set thickness(t){this.getRenderer().postproduction.outlinePass.thickness=t}get fillColor(){return this.getRenderer().postproduction.outlinePass.fillColor}set fillColor(t){this.getRenderer().postproduction.outlinePass.fillColor.copy(t)}get fillOpacity(){return this.getRenderer().postproduction.outlinePass.fillOpacity}set fillOpacity(t){const e=this.getRenderer().postproduction;e.outlinePass.fillOpacity=t}setupEvents(){const t=this.components.get(p);this.styles.guard=e=>t.styles.has(e),this.styles.onItemAdded.add(e=>{const i=this.components.get(p),s=()=>{this._activeStyles.add(e),this.updateFromStyles()},r=()=>{this._activeStyles.delete(e),this.updateFromStyles()};this._styleCallbacks[e]={onHighlight:s,onClear:r},i.events[e].onHighlight.add(s),i.events[e].onClear.add(r)}),this.styles.onBeforeDelete.add(e=>{const{onHighlight:i,onClear:s}=this._styleCallbacks[e];t.events[e].onHighlight.remove(i),t.events[e].onClear.remove(s),this._activeStyles.delete(e),delete this._styleCallbacks[e]}),t.styles.onItemDeleted.add(e=>this.styles.delete(e))}async updateFromStyles(){const t=this.components.get(p),e=[];for(const s of this._activeStyles){const r=t.selection[s];r&&e.push(r)}const i=c.join(e);this._map=i,await this.update()}async update(t=this._map){if(t===this._map&&this.cleanMeshes(),this.outlinePositions&&this.updatePoints(),Object.keys(t).length===0)return;const e=this.components.get(m),s=this.getRenderer().postproduction.outlinePass,l=await this.components.get(F).get(t);for(const d of Object.keys(t))if(e.list.get(d))for(const[M,f]of l.entries()){const _=[...f.values()].flat();for(const u of _)this._meshes.push(u),s.scene.add(u)}}async addItems(t){c.add(this._map,t),await this.update(t)}async removeItems(t){c.remove(this._map,t),await this.update()}clean(){this._map={},this._activeStyles.clear(),this.cleanMeshes(),this._mesh&&this.components.get(v).destroy(this._mesh,!0,!0),this._mesh=null}dispose(){this.styles.clear(),this.clean(),this.onDisposed.trigger(h.uuid)}cleanMeshes(){for(const t of this._meshes)t.removeFromParent();this._meshes=[]}async updatePoints(){let t=0;for(const[s,r]of Object.entries(this._map))t+=r.size;this._points.geometry.setAttribute("position",new E(new Float32Array(t*3),3));const i=await this.components.get(m).getPositions(this._map);for(let s=0;s<i.length;s++){const{x:r,y:l,z:d}=i[s];this._points.geometry.attributes.position.array[s*3]=r,this._points.geometry.attributes.position.array[s*3+1]=l,this._points.geometry.attributes.position.array[s*3+2]=d}this._points.geometry.attributes.position.needsUpdate=!0}getRenderer(){if(!this.world)throw new Error("You must set a world to use the outliner!");const t=this.world.renderer;if(!t.postproduction)throw new Error("The world given to the outliner must use the postproduction renderer.");return t}};o(h,"uuid","2fd3bcc5-b3b6-4ded-9f64-f47a02854a10");let g=h;export{g as O};
