var x=Object.defineProperty;var C=(e,r,s)=>r in e?x(e,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[r]=s;var a=(e,r,s)=>(C(e,typeof r!="symbol"?r+"":r,s),s);import{aa as M,O as _,r as D,Q as R,I as F,du as L,dv as B,p as W,aw as P,M as A,aE as U,ax as k,V as w,dw as O,a as I}from"./index-D7EC26VF.js";import{E,S as j,C as N,W as z,a as G,O as V,F as Q}from"./index-Bv9-N0Ab.js";import{G as X}from"./index-l9Fj5h2Z.js";function Z(e,r,s,i){return new Promise((t,o)=>{function h(){const d=e.clientWaitSync(r,s,0);if(d===e.WAIT_FAILED){o();return}if(d===e.TIMEOUT_EXPIRED){setTimeout(h,i);return}t()}h()})}async function K(e,r,s,i,t,o,h){const d=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),await Z(e,d,0,10),e.deleteSync(d),e.bindBuffer(r,s),e.getBufferSubData(r,i,t,o,h),e.bindBuffer(r,null)}async function Y(e,r,s,i,t,o,h,d){const u=e.createBuffer();return e.bindBuffer(e.PIXEL_PACK_BUFFER,u),e.bufferData(e.PIXEL_PACK_BUFFER,d.byteLength,e.STREAM_READ),e.readPixels(r,s,i,t,o,h,0),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),await K(e,e.PIXEL_PACK_BUFFER,u,0,d),e.deleteBuffer(u),d}class q{constructor(r,s){a(this,"onDisposed",new E);a(this,"onDistanceComputed",new E);a(this,"excludedObjects",new Set);a(this,"enabled",!0);a(this,"renderDebugFrame",!1);a(this,"components");a(this,"scene",new M);a(this,"camera",new _(-1,1,1,-1,0,1));a(this,"depthMaterial");a(this,"world");a(this,"worker");a(this,"_width",512);a(this,"_height",512);a(this,"_postQuad");a(this,"tempRT");a(this,"resultRT");a(this,"bufferSize");a(this,"_buffer");a(this,"_isWorkerBusy",!1);a(this,"compute",async()=>{if(!this.enabled||this.world.isDisposing||this._isWorkerBusy)return;this._isWorkerBusy=!0,this.world.camera.three.updateMatrix();const r=this.world.renderer.three;r.setRenderTarget(this.tempRT);const s="visibilityBeforeDistanceCheck";for(const t of this.excludedObjects)t.userData[s]=t.visible,t.visible=!1;r.render(this.world.scene.three,this.world.camera.three);for(const t of this.excludedObjects)t.userData[s]!==void 0&&(t.visible=t.userData[s]);this.depthMaterial.uniforms.tDiffuse.value=this.tempRT.texture,this.depthMaterial.uniforms.tDepth.value=this.tempRT.depthTexture,r.setRenderTarget(this.resultRT),r.render(this.scene,this.camera);const i=r.getContext();try{await Y(i,0,0,this._width,this._height,i.RGBA,i.UNSIGNED_BYTE,this._buffer)}catch{r.setRenderTarget(null),this._isWorkerBusy=!1;return}r.setRenderTarget(null),this.renderDebugFrame&&r.render(this.scene,this.camera),this.worker.postMessage({buffer:this._buffer})});a(this,"handleWorkerMessage",r=>{if(!this.enabled||this.world.isDisposing)return;const s=r.data.colors;let i=Number.MAX_VALUE;for(const u of s)u!==0&&u<i&&(i=u);const t=this.world.camera.three||_,h=(i/255-1)*-1*(t.far-t.near),d=Math.min(h,t.far);this.onDistanceComputed.trigger(d),this._isWorkerBusy=!1});if(!s.renderer)throw new Error("The given world must have a renderer!");this.components=r,this.world=s;const i=s.camera.three;this.tempRT=new D(this._width,this._height),this.bufferSize=this._width*this._height*4,this._buffer=new Uint8Array(this.bufferSize),this.tempRT.texture.minFilter=R,this.tempRT.texture.magFilter=R,this.tempRT.stencilBuffer=!1,this.tempRT.samples=0,this.tempRT.depthTexture=new F(this._width,this._height),this.tempRT.depthTexture.format=L,this.tempRT.depthTexture.type=B,this.resultRT=new D(this._width,this._height),this.depthMaterial=new W({vertexShader:`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
    `,fragmentShader:`
#include <packing>

varying vec2 vUv;
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
uniform float cameraNear;
uniform float cameraFar;


float readDepth( sampler2D depthSampler, vec2 coord ) {
  float fragCoordZ = texture2D( depthSampler, coord ).x;
  float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
  return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
}

void main() {
  //vec3 diffuse = texture2D( tDiffuse, vUv ).rgb;
  float depth = readDepth( tDepth, vUv );

  gl_FragColor.rgb = 1.0 - vec3( depth );
  gl_FragColor.a = 1.0;
}
    `,uniforms:{cameraNear:{value:i.near},cameraFar:{value:i.far},tDiffuse:{value:null},tDepth:{value:null}}});const t=new P(2,2);this._postQuad=new A(t,this.depthMaterial),this.scene.add(this._postQuad);const o=`
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Set();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          colors.add(r);
        }
        postMessage({ colors });
      });
    `,h=new Blob([o],{type:"application/javascript"});this.worker=new Worker(URL.createObjectURL(h)),this.worker.addEventListener("message",this.handleWorkerMessage)}dispose(){this.enabled=!1,this.onDistanceComputed.reset(),this.worker.terminate(),this.tempRT.dispose(),this.resultRT.dispose();const r=[...this.scene.children];this.excludedObjects.clear();for(const s of r)s.removeFromParent();this._postQuad.geometry.dispose(),this._postQuad.removeFromParent(),this._buffer=null,this.onDisposed.reset()}}class H extends j{constructor(){super(...arguments);a(this,"_distanceRenderer");a(this,"autoBias",!0);a(this,"_defaultShadowConfig",{cascade:1,resolution:512});a(this,"_lightsWithShadow",new Map);a(this,"_isComputingShadows",!1);a(this,"_shadowsEnabled",!0);a(this,"_bias",0);a(this,"recomputeShadows",s=>{if(!this._shadowsEnabled)return;if(this.autoBias&&(this.bias=-.005),s*=1.5,!this.currentWorld)throw new Error("A world needs to be assigned to the scene before computing shadows!");if(!this._lightsWithShadow.size)throw new Error("No shadows found!");const t=this.currentWorld.camera.three;if(!(t instanceof k)&&!(t instanceof _))throw new Error("Invalid camera type!");const o=new w;t.getWorldDirection(o);let h=s;const d=new w;d.copy(this.config.directionalLight.position),d.normalize();for(const[u,T]of this._lightsWithShadow){const c=this.directionalLights.get(T);if(!c)throw new Error("Light not found.");const m=new w;m.copy(o);const v=u===this._lightsWithShadow.size-1,y=v?h/2:h*2/3;m.multiplyScalar(y),m.add(t.position);const f=h-y,g=new w;g.copy(d),g.multiplyScalar(f),c.target.position.copy(m),c.position.copy(m),c.position.add(g),c.shadow.camera.right=f,c.shadow.camera.left=-f,c.shadow.camera.top=f,c.shadow.camera.bottom=-f,c.shadow.camera.far=f*2,c.shadow.camera.updateProjectionMatrix(),c.shadow.camera.updateMatrix(),v||(h/=3)}this._isComputingShadows=!1})}get bias(){return this._bias}set bias(s){this._bias=s;for(const[,i]of this._lightsWithShadow){const t=this.directionalLights.get(i);t&&(t.shadow.bias=s)}}get shadowsEnabled(){return this._shadowsEnabled}set shadowsEnabled(s){this._shadowsEnabled=s;for(const[,i]of this.directionalLights)i.castShadow=s}get distanceRenderer(){if(!this._distanceRenderer)throw new Error("You must set up this component before accessing the distance renderer!");return this._distanceRenderer}setup(s){super.setup(s);const i={...this._defaultConfig,...this._defaultShadowConfig,...s};if(i.cascade<=0)throw new Error("Config.shadows.cascade must be a natural number greater than 0!");if(i.cascade>1)throw new Error("Multiple shadows not supported yet!");if(!this.currentWorld)throw new Error("A world needs to be assigned to the scene before setting it up!");for(const[,t]of this.directionalLights)t.target.removeFromParent(),t.removeFromParent(),t.dispose();this.directionalLights.clear(),this._distanceRenderer||(this._distanceRenderer=new q(this.components,this.currentWorld),this._distanceRenderer.onDistanceComputed.add(this.recomputeShadows)),this._lightsWithShadow.clear();for(let t=0;t<i.cascade;t++){const o=new U;o.intensity=this.config.directionalLight.intensity,o.color=this.config.directionalLight.color,o.position.copy(this.config.directionalLight.position),o.shadow.mapSize.width=i.resolution,o.shadow.mapSize.height=i.resolution,this.three.add(o,o.target),this.directionalLights.set(o.uuid,o),this._lightsWithShadow.set(t,o.uuid),o.castShadow=!0,o.shadow.bias=this._bias}}dispose(){super.dispose(),this._distanceRenderer&&this._distanceRenderer.dispose(),this._lightsWithShadow.clear()}async updateShadows(){this._isComputingShadows||!this._shadowsEnabled||(this._isComputingShadows=!0,await this.distanceRenderer.compute())}}const J=document.getElementById("container"),l=new N,$=l.get(z),n=$.create();n.scene=new H(l);n.renderer=new G(l,J);n.camera=new V(l);l.init();n.camera.controls.setLookAt(12,6,8,0,0,-10);const ee=l.get(X),te=ee.create(n),b=l.get(Q);b.init("https://thatopen.github.io/engine_fragment/resources/worker.mjs");n.camera.controls.addEventListener("control",()=>b.core.update());const se="example",re=await fetch("https://thatopen.github.io/engine_components/resources/frags/school_arq.frag"),ae=await re.arrayBuffer(),ie=new Uint8Array(ae),S=await b.core.load(ie,{modelId:se,camera:n.camera.three});n.scene.three.add(S.object);n.renderer.three.shadowMap.enabled=!0;n.renderer.three.shadowMap.type=O;n.scene.setup({shadows:{cascade:1,resolution:1024}});n.scene.distanceRenderer.excludedObjects.add(te.three);S.tiles.onItemSet.add(({value:e})=>{"isMesh"in e&&e.material[0].opacity===1&&(e.castShadow=!0,e.receiveShadow=!0)});for(const e of S.object.children)e.castShadow=!0,e.receiveShadow=!0;await n.scene.updateShadows();n.camera.controls.addEventListener("rest",async()=>{await n.scene.updateShadows()});n.scene.three.background=null;const p=new I;p.showPanel(2);document.body.append(p.dom);p.dom.style.left="0px";p.dom.style.zIndex="unset";n.renderer.onBeforeUpdate.add(()=>p.begin());n.renderer.onAfterUpdate.add(()=>p.end());
