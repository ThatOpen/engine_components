var w=Object.defineProperty;var b=(h,n,t)=>n in h?w(h,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[n]=t;var o=(h,n,t)=>(b(h,typeof n!="symbol"?n+"":n,t),t);import{c as P,E as v,M as p,F as g,D as C}from"./graphic-vertex-picker-CqNhsDsK.js";import{W as R,k,c as S,l as E,F}from"./index-lvtjgYNN.js";import{H as u}from"./index-Cah51jn0.js";import{M as D}from"./index-B41enjmT.js";const l=class l extends P{constructor(t){super(t);o(this,"_world");o(this,"styles",new R);o(this,"outlinePositions",!1);o(this,"_mesh",null);o(this,"onDisposed",new v);o(this,"_meshes",[]);o(this,"_map",{});o(this,"_activeStyles",new Set);o(this,"_styleCallbacks",{});t.add(l.uuid,this),this.setupEvents()}set world(t){if(this._world=t,!t)return;this.getRenderer().postproduction.excludedObjectsPass.addExcludedMaterial(this._points.material)}get world(){return this._world}get _points(){return this._mesh||(this._mesh=new k(new S,new E({size:10,sizeAttenuation:!1,depthTest:!1}))),this._mesh}get enabled(){return!this.world||this.world.isDisposing?!1:this.getRenderer().postproduction.outlinesEnabled}set enabled(t){if(!this.world||this.world.isDisposing)return;const e=this.getRenderer();e.postproduction.outlinesEnabled=t,this.outlinePositions&&(this._points.material.color=this.color,this.world.scene.three.add(this._points))}get color(){return this.getRenderer().postproduction.outlinePass.outlineColor}set color(t){this.getRenderer().postproduction.outlinePass.outlineColor.copy(t),this._points.material.color.copy(t)}get thickness(){return this.getRenderer().postproduction.outlinePass.thickness}set thickness(t){this.getRenderer().postproduction.outlinePass.thickness=t}get fillColor(){return this.getRenderer().postproduction.outlinePass.fillColor}set fillColor(t){this.getRenderer().postproduction.outlinePass.fillColor.copy(t)}get fillOpacity(){return this.getRenderer().postproduction.outlinePass.fillOpacity}set fillOpacity(t){const e=this.getRenderer().postproduction;e.outlinePass.fillOpacity=t}setupEvents(){const t=this.components.get(u);this.styles.guard=e=>t.styles.has(e),this.styles.onItemAdded.add(e=>{const i=this.components.get(u),s=()=>{this._activeStyles.add(e),this.updateFromStyles()},r=()=>{this._activeStyles.delete(e),this.updateFromStyles()};this._styleCallbacks[e]={onHighlight:s,onClear:r},i.events[e].onHighlight.add(s),i.events[e].onClear.add(r)}),this.styles.onBeforeDelete.add(e=>{const{onHighlight:i,onClear:s}=this._styleCallbacks[e];t.events[e].onHighlight.remove(i),t.events[e].onClear.remove(s),this._activeStyles.delete(e),delete this._styleCallbacks[e]}),t.styles.onItemDeleted.add(e=>this.styles.delete(e))}async updateFromStyles(){const t=this.components.get(u),e=[];for(const s of this._activeStyles){const r=t.selection[s];r&&e.push(r)}const i=p.join(e);this._map=i,await this.update()}async update(t=this._map){if(t===this._map&&this.cleanMeshes(),this.outlinePositions&&this.updatePoints(),Object.keys(t).length===0)return;const e=this.components.get(g),s=this.getRenderer().postproduction.outlinePass,d=await this.components.get(D).get(t);for(const c of Object.keys(t)){const m=e.list.get(c);if(m)for(const[M,_]of d.entries()){const y=[..._.values()].flat();for(const a of y)a.position.set(0,0,0),a.rotation.set(0,0,0),a.scale.set(1,1,1),a.applyMatrix4(m.object.matrixWorld),this._meshes.push(a),s.scene.add(a)}}}async addItems(t){p.add(this._map,t),await this.update(t)}async removeItems(t){p.remove(this._map,t),await this.update()}clean(){this._map={},this._activeStyles.clear(),this.cleanMeshes(),this._mesh&&this.components.get(C).destroy(this._mesh,!0,!0),this._mesh=null}dispose(){this.styles.clear(),this.clean(),this.onDisposed.trigger(l.uuid)}cleanMeshes(){for(const t of this._meshes)t.removeFromParent();this._meshes=[]}async updatePoints(){let t=0;for(const[s,r]of Object.entries(this._map))t+=r.size;this._points.geometry.setAttribute("position",new F(new Float32Array(t*3),3));const i=await this.components.get(g).getPositions(this._map);for(let s=0;s<i.length;s++){const{x:r,y:d,z:c}=i[s];this._points.geometry.attributes.position.array[s*3]=r,this._points.geometry.attributes.position.array[s*3+1]=d,this._points.geometry.attributes.position.array[s*3+2]=c}this._points.geometry.attributes.position.needsUpdate=!0}getRenderer(){if(!this.world)throw new Error("You must set a world to use the outliner!");const t=this.world.renderer;if(!t.postproduction)throw new Error("The world given to the outliner must use the postproduction renderer.");return t}};o(l,"uuid","2fd3bcc5-b3b6-4ded-9f64-f47a02854a10");let f=l;export{f as O};
