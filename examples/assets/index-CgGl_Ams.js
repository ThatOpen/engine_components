var D=Object.defineProperty;var N=(y,m,e)=>m in y?D(y,m,{enumerable:!0,configurable:!0,writable:!0,value:e}):y[m]=e;var n=(y,m,e)=>(N(y,typeof m!="symbol"?m+"":m,e),e);import{c as T,E as p,g as O,R as E,M as v,F as b}from"./graphic-vertex-picker-D88BIZW2.js";import{z as j,C as x,Y as B,S as z,j as H}from"./index-BET5fVdQ.js";const M=class M extends T{constructor(e){super(e);n(this,"onDisposed",new p);n(this,"onBeforeUpdate",new p);n(this,"onAfterUpdate",new p);n(this,"onSetup",new p);n(this,"isSetup",!1);n(this,"enabled",!0);n(this,"events",{});n(this,"multiple","ctrlKey");n(this,"zoomFactor",1.5);n(this,"zoomToSelection",!1);n(this,"backupColor",null);n(this,"selection",{});n(this,"config",{selectName:"select",selectionColor:null,autoHighlightOnClick:!0,world:null,selectEnabled:!0,autoUpdateFragments:!0,selectMaterialDefinition:{color:new x("#BCF124"),renderedFaces:j.ONE,opacity:1,transparent:!1}});n(this,"styles",new B);n(this,"autoToggle",new Set);n(this,"mouseDownPosition",{x:0,y:0});n(this,"mouseMoveThreshold",5);n(this,"selectable",{});n(this,"eventManager",new O);n(this,"_mouseState",{down:!1,moved:!1});n(this,"_fromHighlight",!1);n(this,"restorePreviousColors",(e=this.selection.select)=>{for(const[t,s]of Object.entries(this.selection))if(!(t===this.config.selectName||!this.styles.get(t)))for(const[i,r]of Object.entries(e)){const l=s[i];if(!l)continue;const c=[...r].filter(h=>l.has(h));c.length!==0&&new Set(c)}});n(this,"onMouseDown",e=>{this.enabled&&(this.debounceTimeout&&clearTimeout(this.debounceTimeout),this.mouseDownPosition={x:e.clientX,y:e.clientY},this._mouseState.down=!0)});n(this,"debounceTimeout",null);n(this,"onMouseUp",async e=>{if(!this.enabled)return;const{world:t,autoHighlightOnClick:s,selectEnabled:o}=this.config;if(!t)throw new Error("No world found!");if(!t.renderer)throw new Error("This world doesn't have a renderer!");if(e.target===t.renderer.three.domElement){if(this._mouseState.down=!1,this._mouseState.moved||e.button!==0){this._mouseState.moved=!1;return}if(this._mouseState.moved=!1,s&&o){const i=this.multiple==="none"?!0:!e[this.multiple];await this.highlight(this.config.selectName,i,this.zoomToSelection)}}});n(this,"onMouseMove",async e=>{if(!this.enabled)return;const t=e.clientX-this.mouseDownPosition.x,s=e.clientY-this.mouseDownPosition.y,o=Math.sqrt(t*t+s*s);this._mouseState.moved||o>this.mouseMoveThreshold&&(this._mouseState.moved=this._mouseState.down)});this.components.add(M.uuid,this),this.eventManager.list.add(this.onSetup),this.eventManager.list.add(this.onDisposed),this.setStyleEvents()}setStyleEvents(){this.styles.onBeforeDelete.add(async({key:e})=>{if(await this.clear(e),delete this.selection[e],!(e in this.events))return;const{onClear:t,onHighlight:s,onBeforeHighlight:o}=this.events[e];this.eventManager.list.delete(t),this.eventManager.list.delete(s),this.eventManager.list.delete(o),delete this.events[e]}),this.styles.onItemSet.add(({key:e})=>{this.selection[e]={};const t=new p,s=new p,o=new p;this.events[e]={onHighlight:t,onClear:o,onBeforeHighlight:s},this.eventManager.add([o,t,s])})}async dispose(){this.setupEvents(!1),this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.selection={},this.styles.clear(),this.onDisposed.trigger(M.uuid),this.eventManager.reset(),this.isSetup=!1}add(e){if(console.warn("highlighter.add() is deprecated, use highlighter.styles.set() instead"),typeof e=="string")this.styles.set(e,null);else{const{customId:t}=e;this.styles.set(t,e)}}async remove(e){console.warn("highlighter.remove() is deprecated, use highlighter.styles.delete() instead"),this.styles.delete(e)}async highlight(e,t=!0,s=this.zoomToSelection,o=null){if(!this.enabled)return;if(!this.config.world)throw new Error("No world found in config!");const i=this.config.world;if(!this.selection[e])throw new Error(`Selection ${e} does not exist.`);const c=await this.components.get(E).get(i).castRay();if(!c||c.localId===void 0||c.localId===null){t&&this.clear(e);return}const{localId:h,fragments:{modelId:u}}=c,a={[u]:new Set([h])};await this.highlightByID(e,a,t,s,o,!0)}async highlightByID(e,t,s=!0,o=this.zoomToSelection,i=null,r=!1){var u;if(!this.enabled)return;this._fromHighlight=!0,this.events[e].onBeforeHighlight.trigger(this.selection[e]),s&&await this.clear(e);let l=v.clone(t);const c=this.components.get(b);for(const[a,g]of Object.entries(t)){const f=c.list.get(a);f!=null&&f.isDeltaModel&&f.parentModelId&&v.add(l,{[f.parentModelId]:g})}const h=(u=this.selectable)==null?void 0:u[e];if(h){const a=v.clone(h);l=v.intersect([l,a])}if(i){const a=v.clone(i);for(const[g,f]of Object.entries(a)){const d=c.list.get(g);d!=null&&d.deltaModelId&&v.add(a,{[d.deltaModelId]:f})}v.remove(l,i)}if(r&&this.autoToggle.has(e)){const a={};let g=!1;for(const f in l){const d=this.selection[e][f];if(!d)continue;const I=l[f];for(const S of I)if(d.has(S)){d.delete(S);let w=a[f];w||(w=new Set,a[f]=w),w.add(S),g=!0}else d.add(S);l[f]=d}g&&(this.events[e].onClear.trigger(a),e===this.config.selectName&&this.restorePreviousColors(a))}this.updateStyleMap(e,l),this.events[e].onHighlight.trigger(this.selection[e]),this._fromHighlight=!1,await this.updateColors(),o&&await this.zoomSelection(l)}async updateColors(){const e=this.components.get(b),t=[e.resetHighlight()];for(const[s,o]of Object.entries(this.selection)){const i=this.styles.get(s);if(!i)continue;const r=s==="select"||!this.styles.get(this.config.selectName)?o:this.getMapWithoutSelection(s);r&&t.push(e.highlight({...i,customId:s},r))}this.config.autoUpdateFragments&&t.push(e.core.update(!0)),await Promise.allSettled(t)}updateStyleMap(e,t){const s=this.selection[e];for(const o in t){let i=s[o];i||(i=new Set,s[o]=i);const r=t[o];for(const l of r)i.add(l)}if(e!==this.config.selectName)for(const[o,i]of Object.entries(this.selection)){if(o===this.config.selectName||o===e)continue;const r=i;for(const[l,c]of Object.entries(s)){const h=r[l];if(h)for(const u of c)h.delete(u)}}}getMapWithoutSelection(e,t){const s=this.selection[e];if(!s)throw new Error(`Style ${e} does not exist.`);const o=this.selection[this.config.selectName]??{},i={};for(const r in s){const l=s[r],c=e===this.config.selectName?new Set:o[r]??new Set,h=Array.from(l).filter(u=>{var a;return!c.has(u)&&(!t||((a=t[r])==null?void 0:a.has(u)))});h.length>0&&(i[r]=new Set(h))}return Object.keys(i).length>0?i:null}async clear(e,t){const s=e?[e]:Object.keys(this.selection),o=t??void 0;for(const i of s){const r=this.selection[i]??{},l=o??r;i===this.config.selectName&&this.restorePreviousColors();const c={};for(const[h,u]of Object.entries(l)){const a=r[h];if(a)for(const g of u){if(!a.delete(g))continue;let d=c[h];d||(d=new Set,c[h]=d),d.add(g)}}Object.keys(c).length>0&&this.events[i].onClear.trigger(c),this.selection[i]={}}this._fromHighlight||await this.updateColors()}setup(e){if(this.isSetup)return;this.config={...this.config,...e};const{selectName:t,selectionColor:s,selectMaterialDefinition:o}=this.config;this.config.world&&this.components.get(E).get(this.config.world),o?(s&&(console.warn("highlighter.config.selectionColor is deprecated, use selectMaterialDefinition instead"),o.color=s),this.styles.set(t,o)):this.styles.set(t,null),this.autoToggle.add(this.config.selectName),this.setupEvents(!0),this.enabled=!0,this.isSetup=!0,this.onSetup.trigger(this)}async zoomSelection(e){if(!this.config.world)throw new Error("No world found in config!");const t=this.config.world;let s=!1;for(const w in e)if(e[w].size>0){s=!0;break}if(!s||!t.camera.hasCameraControls())return;const i=await this.components.get(b).getBBoxes(e),r=new z,l=new H;for(const w of i)l.union(w);l.getBoundingSphere(r);const c=1/0,h=-1/0,{x:u,y:a,z:g}=r.center,f=r.radius===c||u===c||a===c||g===c,d=r.radius===h||u===h||a===h||g===h,I=r.radius===0;if(f||d||I)return;r.radius*=this.zoomFactor,await t.camera.controls.fitToSphere(r,!0)}setupEvents(e){if(!this.config.world){console.log("No world found while setting up events!");return}if(this.config.world.isDisposing)return;if(!this.config.world.renderer)throw new Error("The given world doesn't have a renderer!");const t=this.config.world.renderer.three.domElement;t.removeEventListener("mousedown",this.onMouseDown),t.removeEventListener("mouseup",this.onMouseUp),t.removeEventListener("pointermove",this.onMouseMove),e&&(t.addEventListener("mousedown",this.onMouseDown),t.addEventListener("mouseup",this.onMouseUp),t.addEventListener("pointermove",this.onMouseMove))}};n(M,"uuid","cb8a76f2-654a-4b50-80c6-66fd83cafd77");let C=M;export{C as H};
