var H=Object.defineProperty;var T=(u,a,e)=>a in u?H(u,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[a]=e;var n=(u,a,e)=>(T(u,typeof a!="symbol"?a+"":a,e),e);import{b as A,F as S,E as O,c as C,D as j}from"./graphic-vertex-picker-DJhsmSZm.js";import{Y as _,d as G,l as R,M as B,W as z,n as Y,o as U,F as W}from"./index-CZukAoYd.js";import{H as D}from"./index-CV_r3Qsl.js";const b=class b extends A{constructor(){super(...arguments);n(this,"enabled",!0);n(this,"geometries",new _);n(this,"onDisposed",new O)}async get(e,t){const{material:o,coordinate:s,applyTransformation:i}={coordinate:!0,applyTransformation:!0,...t},r=this.components.get(S),h=new _;for(const[l,c]of Object.entries(e)){const d=r.list.get(l);if(!d)continue;const x=this.getModelMeshes(l);for(const m of c){let g=h.get(l);g||(g=new _,h.set(l,g));let p=x.get(m);if(p&&p.length>0){const y=[];for(const[w,{geometry:v,transform:M}]of p.entries()){const P=await this.createMesh(d,v,M,{material:o,applyTransformation:i,coordinate:s});y.push(P)}g.set(m,y);continue}else p=[],x.set(m,p);const[F]=await d.getItemsGeometry([m]);if(!F)continue;const E=[];for(const y of F){const w=this.createGeometry(y);if(!w)continue;const{geometry:v,transform:M}=w;p.push(w);const P=await this.createMesh(d,v,M,{material:o,applyTransformation:i,coordinate:s});E.push(P)}g.set(m,E)}}return h}getModelMeshes(e){let t=this.geometries.get(e);return t||(t=new _,this.geometries.set(e,t)),t}remove(e=[...this.geometries.keys()]){for(const t of e){const o=this.geometries.get(t);if(o){for(const[s,i]of o)for(const{geometry:r}of i)r.dispose();this.geometries.delete(t)}}}dispose(e=!0){this.remove(),e&&this.geometries.dispose(),this.onDisposed.trigger(b.uuid)}getMeshesFromResult(e){const t=[];for(const o of e.values())for(const s of o.values())t.push(...s);return t}createGeometry(e){const{positions:t,indices:o,normals:s,transform:i}=e;if(!(t&&o&&s))return null;const r=new G;return r.setAttribute("position",new R(t,3)),r.setAttribute("normal",new R(s,3,!0)),r.setIndex(new R(o,1)),{geometry:r,transform:i}}async createMesh(e,t,o,s){const{material:i,applyTransformation:r,coordinate:h}={applyTransformation:!0,coordinate:!0,...s},l=this.components.get(S),c=new B(t,i);if(c.applyMatrix4(o),r||c.position.set(0,0,0),h&&l.baseCoordinationModel!==e.modelId){const d=await e.getCoordinationMatrix();l.applyBaseCoordinateSystem(c,d)}return c}};n(b,"uuid","ab45d0a7-feea-4afc-927c-80832dae76dd");let k=b;const f=class f extends A{constructor(e){super(e);n(this,"_world");n(this,"styles",new z);n(this,"outlinePositions",!1);n(this,"_mesh",null);n(this,"onDisposed",new O);n(this,"_meshes",[]);n(this,"_map",{});n(this,"_activeStyles",new Set);n(this,"_styleCallbacks",{});e.add(f.uuid,this),this.setupEvents()}set world(e){if(this._world=e,!e)return;this.getRenderer().postproduction.excludedObjectsPass.addExcludedMaterial(this._points.material)}get world(){return this._world}get _points(){return this._mesh||(this._mesh=new Y(new G,new U({size:10,sizeAttenuation:!1,depthTest:!1}))),this._mesh}get enabled(){return!this.world||this.world.isDisposing?!1:this.getRenderer().postproduction.outlinesEnabled}set enabled(e){if(!this.world||this.world.isDisposing)return;const t=this.getRenderer();t.postproduction.outlinesEnabled=e,this.outlinePositions&&(this._points.material.color=this.color,this.world.scene.three.add(this._points))}get color(){return this.getRenderer().postproduction.outlinePass.outlineColor}set color(e){this.getRenderer().postproduction.outlinePass.outlineColor.copy(e),this._points.material.color.copy(e)}get thickness(){return this.getRenderer().postproduction.outlinePass.thickness}set thickness(e){this.getRenderer().postproduction.outlinePass.thickness=e}get fillColor(){return this.getRenderer().postproduction.outlinePass.fillColor}set fillColor(e){this.getRenderer().postproduction.outlinePass.fillColor.copy(e)}get fillOpacity(){return this.getRenderer().postproduction.outlinePass.fillOpacity}set fillOpacity(e){const t=this.getRenderer().postproduction;t.outlinePass.fillOpacity=e}setupEvents(){const e=this.components.get(D);this.styles.guard=t=>e.styles.has(t),this.styles.onItemAdded.add(t=>{const o=this.components.get(D),s=()=>{this._activeStyles.add(t),this.updateFromStyles()},i=()=>{this._activeStyles.delete(t),this.updateFromStyles()};this._styleCallbacks[t]={onHighlight:s,onClear:i},o.events[t].onHighlight.add(s),o.events[t].onClear.add(i)}),this.styles.onBeforeDelete.add(t=>{const{onHighlight:o,onClear:s}=this._styleCallbacks[t];e.events[t].onHighlight.remove(o),e.events[t].onClear.remove(s),this._activeStyles.delete(t),delete this._styleCallbacks[t]}),e.styles.onItemDeleted.add(t=>this.styles.delete(t))}async updateFromStyles(){const e=this.components.get(D),t=[];for(const s of this._activeStyles){const i=e.selection[s];i&&t.push(i)}const o=C.join(t);this._map=o,await this.update()}async update(e=this._map){if(e===this._map&&this.cleanMeshes(),this.outlinePositions&&this.updatePoints(),Object.keys(e).length===0)return;const o=this.getRenderer().postproduction.outlinePass,i=await this.components.get(k).get(e);for(const[r,h]of i.entries()){const l=[...h.values()].flat();for(const c of l)this._meshes.push(c),o.scene.add(c)}}async addItems(e){C.add(this._map,e),await this.update(e)}async removeItems(e){C.remove(this._map,e),await this.update()}clean(){this._map={},this._activeStyles.clear(),this.cleanMeshes(),this._mesh&&this.components.get(j).destroy(this._mesh,!0,!0),this._mesh=null}dispose(){this.styles.clear(),this.clean(),this.onDisposed.trigger(f.uuid)}cleanMeshes(){for(const e of this._meshes)e.removeFromParent();this._meshes=[]}async updatePoints(){let e=0;for(const[s,i]of Object.entries(this._map))e+=i.size;this._points.geometry.setAttribute("position",new W(new Float32Array(e*3),3));const o=await this.components.get(S).getPositions(this._map);for(let s=0;s<o.length;s++){const{x:i,y:r,z:h}=o[s];this._points.geometry.attributes.position.array[s*3]=i,this._points.geometry.attributes.position.array[s*3+1]=r,this._points.geometry.attributes.position.array[s*3+2]=h}this._points.geometry.attributes.position.needsUpdate=!0}getRenderer(){if(!this.world)throw new Error("You must set a world to use the outliner!");const e=this.world.renderer;if(!e.postproduction)throw new Error("The world given to the outliner must use the postproduction renderer.");return e}};n(f,"uuid","2fd3bcc5-b3b6-4ded-9f64-f47a02854a10");let I=f;export{I as O};
