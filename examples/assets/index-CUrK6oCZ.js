var k=Object.defineProperty;var $=(b,t,e)=>t in b?k(b,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):b[t]=e;var r=(b,t,e)=>($(b,typeof t!="symbol"?t+"":t,e),e);import{c as G,D as P,z as J,d as q,C as H}from"./import-wrapper-prod-Cw6eyEbm.js";import{M as R,c as W,V as I,a as F,P as K,q as Q,e as ee,z as te,E as se,I as ie,J as ne,L as oe}from"./index-vsiIwi5G.js";import{P as B}from"./index-CYJyRTZd.js";class re{constructor(t,e,s,i){r(this,"mesh",new R(new W));r(this,"world");r(this,"styleName");r(this,"_precission",1e4);r(this,"_tempVector",new I);r(this,"_plane");r(this,"_geometry");r(this,"_plane2DCoordinateSystem",new F);r(this,"_planeAxis");this.world=t,this.mesh.material=i,this.mesh.frustumCulled=!1,this._plane=e;const{x:n,y:l,z:o}=e.normal;Math.abs(n)===1?this._planeAxis="x":Math.abs(l)===1?this._planeAxis="y":Math.abs(o)===1&&(this._planeAxis="z"),this._geometry=s,this.mesh.geometry.attributes.position=s.attributes.position;const h=e.normal.clone().multiplyScalar(.01);this.mesh.position.copy(h),this.visible=!0}get visible(){return this.mesh.parent!==null}set visible(t){const e=this.getStyle();t?(this.world.scene.three.add(this.mesh),e&&e.meshes.add(this.mesh)):(this.mesh.removeFromParent(),e&&e.meshes.delete(this.mesh))}set geometry(t){this._geometry=t,this.mesh.geometry.attributes.position=t.attributes.position}dispose(){const t=this.getStyle();t&&t.meshes.delete(this.mesh),this.mesh.geometry.dispose(),this.mesh.removeFromParent(),this.mesh.geometry=null,this.mesh=null,this._plane=null,this._geometry=null}update(t){const e=this._geometry.attributes.position.array;if(!e)return;this.updatePlane2DCoordinateSystem();const s=[];let i=0;for(let n=0;n<t.length;n++){const l=t[n],o=[];for(let f=i;f<l;f+=2)o.push(f*3);const h=this.computeFill(o,e);for(const f of h)s.push(f);i=l}this.mesh.geometry.setIndex(s)}computeFill(t,e){const s=new Map,i={},n=new Map;let l=0;const o=new Map,h=new Map,f=new Set,p=this._precission;for(let _=0;_<t.length;_++){const y=t[_];let w=0,x=0,m=0,S=0;const V=e[y],D=e[y+1],Y=e[y+2],j=e[y+3],X=e[y+4],Z=e[y+5];if(this._tempVector.set(V,D,Y),this._tempVector.applyMatrix4(this._plane2DCoordinateSystem),w=Math.trunc(this._tempVector.x*p)/p,x=Math.trunc(this._tempVector.y*p)/p,this._tempVector.set(j,X,Z),this._tempVector.applyMatrix4(this._plane2DCoordinateSystem),m=Math.trunc(this._tempVector.x*p)/p,S=Math.trunc(this._tempVector.y*p)/p,w===m&&x===S)continue;const z=`${w}|${x}`,T=`${m}|${S}`;s.has(z)||s.set(z,y/3),s.has(T)||s.set(T,y/3+1);const u=s.get(z),g=s.get(T);i[u]=[w,x],i[g]=[m,S];const U=h.has(u),A=o.has(u),L=h.has(g),C=o.has(g);if(!U&&!A&&!L&&!C)h.set(u,l),o.set(g,l),f.add(l),n.set(l,[u,g]),l++;else if(U&&C){const a=h.get(u),d=o.get(g);if(a!==d){const c=n.get(d),v=n.get(a);if(!c||!v)continue;n.delete(a),f.delete(a),o.set(v[v.length-1],d),o.delete(c[c.length-1]);for(const N of v)c.push(N)}else f.delete(d);h.delete(u),o.delete(g)}else if(A&&L){const a=h.get(g),d=o.get(u);if(a!==d){const c=n.get(d),v=n.get(a);if(!c||!v)continue;n.delete(a),f.delete(a),o.set(v[v.length-1],d),o.delete(c[c.length-1]);for(const N of v)c.push(N)}else f.delete(d);h.delete(g),o.delete(u)}else if(U&&L){const a=h.get(g),d=h.get(u),M=n.get(d),c=n.get(a);if(!M||!c)continue;n.delete(a),f.delete(a),h.delete(M[0]),h.delete(c[0]),o.delete(c[c.length-1]),h.set(c[c.length-1],d),c.reverse(),M.splice(0,0,...c)}else if(A&&C){const a=o.get(g),d=o.get(u),M=n.get(d),c=n.get(a);if(!M||!c)continue;n.delete(a),f.delete(a),o.delete(M[M.length-1]),o.delete(c[c.length-1]),h.delete(c[0]),o.set(c[0],d),c.reverse(),M.push(...c)}else if(U){const a=h.get(u),d=n.get(a);if(!d)continue;d.unshift(g),h.delete(u),h.set(g,a)}else if(A){const a=o.get(u),d=n.get(a);if(!d)continue;d.push(g),o.delete(u),o.set(g,a)}else if(L){const a=h.get(g),d=n.get(a);if(!d)continue;d.unshift(u),h.delete(g),h.set(u,a)}else if(C){const a=o.get(g),d=n.get(a);if(!d)continue;d.push(u),o.delete(g),o.set(u,a)}}const E=[];for(const[_,y]of n){if(f.has(_))continue;const w=[],x=new Map;let m=0;for(const V of y){const D=i[V];w.push(D[0],D[1]),x.set(m++,V)}const S=G(w);for(const V of S){const D=x.get(V);if(D===void 0)throw new Error("Map error!");E.push(D)}}return E}updatePlane2DCoordinateSystem(){this._plane2DCoordinateSystem=new F;const t=new I(1,0,0),e=new I(0,1,0),s=this._plane.normal,i=new I;this._plane.coplanarPoint(i),this._planeAxis==="x"?t.crossVectors(e,s):this._planeAxis==="y"?e.crossVectors(s,t):this._planeAxis==="z"||(t.crossVectors(e,s).normalize(),e.crossVectors(s,t)),this._plane2DCoordinateSystem.fromArray([t.x,t.y,t.z,0,e.x,e.y,e.z,0,s.x,s.y,s.z,0,i.x,i.y,i.z,1]),this._plane2DCoordinateSystem.invert()}getStyle(){if(!this.world.renderer)return null;const t=this.world.renderer instanceof B;return this.styleName&&t?this.world.renderer.postproduction.customEffects.outlinedMeshes[this.styleName]:null}}class le{constructor(t,e,s,i){r(this,"onDisposed",new P);r(this,"onAfterUpdate",new P);r(this,"onBeforeUpdate",new P);r(this,"enabled",!0);r(this,"fillNeedsUpdate",!1);r(this,"components");r(this,"world");r(this,"_edges",{});r(this,"_styles");r(this,"_visible",!0);r(this,"_inverseMatrix",new F);r(this,"_localPlane",new K);r(this,"_tempLine",new Q);r(this,"_tempVector",new I);r(this,"_plane");this.components=t,this.world=e,this._plane=s,this._styles=i}get visible(){return this._visible}get fillVisible(){for(const t in this._edges){const e=this._edges[t];if(e.fill)return e.fill.visible}return!1}set fillVisible(t){for(const e in this._edges){const s=this._edges[e];s.fill&&(s.fill.visible=t)}}async setVisible(t){this._visible=t;const e=Object.keys(this._edges);for(const s of e)this.updateEdgesVisibility(s,t);t&&await this.update()}async update(){const t=this._styles.get();await this.updateDeletedEdges(t);for(const e in t)this.drawEdges(e);this.fillNeedsUpdate=!1}get(){return this._edges}dispose(){const t=Object.keys(this._edges);for(const e of t)this.disposeEdge(e);this.onDisposed.trigger(),this.onDisposed.reset()}newEdgesMesh(t){const s=this._styles.get()[t].lineMaterial,i=new W,n=new Float32Array(3e5),l=new ee(n,3,!1);l.setUsage(te),i.setAttribute("position",l);const o=new se(i,s);return o.frustumCulled=!1,o}newFillMesh(t,e){const i=this._styles.get()[t],n=i.fillMaterial;if(n){const l=new re(this.world,this._plane,e,n);return this.newFillOutline(t,l,i),l}}newFillOutline(t,e,s){if(!s.outlineMaterial||!this.world.renderer)return;const i=this.world.renderer;if(i instanceof B){const l=i.postproduction.customEffects.outlinedMeshes;l[t]||(l[t]={meshes:new Set,material:s.outlineMaterial}),e.styleName=t}}drawEdges(t){const e=this._styles.get()[t];this._edges[t]||this.initializeStyle(t);const s=this._edges[t];let i=0;const n=s.mesh.geometry.attributes.position;n.array.fill(0);const l=[];let o=0;for(const p of e.meshes)if(p.geometry){if(!p.geometry.boundsTree)throw new Error("Bounds tree not found for clipping edges subset.");if(p instanceof ie){if(p.count===0)continue;const E=p;for(let _=0;_<E.count;_++){const y=E instanceof ne,w=E,x=e.fragments[w.fragment.id];if(y&&x){const V=w.fragment.getItemID(_);if(V===null||!x.has(V))continue}const m=new R(p.geometry);m.matrix.copy(p.matrix);const S=new F;E.getMatrixAt(_,S),m.applyMatrix4(S),m.applyMatrix4(p.matrix),m.updateMatrix(),m.updateMatrixWorld(),this._inverseMatrix.copy(m.matrixWorld).invert(),this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix),i=this.shapecast(m,n,i),i!==o&&(l.push(i),o=i)}}else this._inverseMatrix.copy(p.matrixWorld).invert(),this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix),i=this.shapecast(p,n,i),i!==o&&(l.push(i),o=i)}s.mesh.geometry.setDrawRange(0,i),s.mesh.position.copy(this._plane.normal).multiplyScalar(1e-4),n.needsUpdate=!0;const f=s.mesh.geometry.attributes.position;Number.isNaN(f.array[0])||(s.mesh.parent||this.world.scene.three.add(s.mesh),this.fillNeedsUpdate&&s.fill&&(s.fill.geometry=s.mesh.geometry,s.fill.update(l)))}initializeStyle(t){const e=this.newEdgesMesh(t),s=e.geometry,i=this.newFillMesh(t,s);this._edges[t]={mesh:e,name:t,fill:i}}shapecast(t,e,s){return t.geometry.boundsTree.shapecast({intersectsBounds:i=>this._localPlane.intersectsBox(i),intersectsTriangle:i=>{let n=0;if(this._tempLine.start.copy(i.a),this._tempLine.end.copy(i.b),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const l=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,l.x,l.y,l.z),n++,s++}if(this._tempLine.start.copy(i.b),this._tempLine.end.copy(i.c),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const l=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,l.x,l.y,l.z),n++,s++}if(this._tempLine.start.copy(i.c),this._tempLine.end.copy(i.a),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const l=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,l.x,l.y,l.z),n++,s++}n!==2&&(s-=n)}}),s}updateEdgesVisibility(t,e){const s=this._edges[t];s.fill&&(s.fill.visible=e),s.mesh.visible=e,e?this.world.scene.three.add(s.mesh):s.mesh.removeFromParent()}async updateDeletedEdges(t){const e=Object.keys(this._edges);for(const s of e)t[s]===void 0&&(this.disposeEdge(s),this.disposeOutline(s))}disposeOutline(t){if(!this.world.renderer)return;const e=this.world.renderer;if(e instanceof B){const s=e.postproduction.customEffects.outlinedMeshes;delete s[t]}}disposeEdge(t){const e=this.components.get(J),s=this._edges[t];s.fill&&s.fill.dispose(),e.destroy(s.mesh,!1),delete this._edges[t]}}class ae extends q{constructor(e,s,i,n,l,o){super(e,s,i,n,l,5,!1);r(this,"edges");r(this,"edgesMaxUpdateRate",50);r(this,"lastUpdate",-1);r(this,"updateTimeout",-1);r(this,"updateFill",async()=>{this.edges.fillNeedsUpdate=!0,await this.edges.update(),this._visible&&(this.edges.fillVisible=!0)});r(this,"update",async()=>{if(!this.enabled)return;this.three.setFromNormalAndCoplanarPoint(this.normal,this._helper.position);const e=Date.now();this.lastUpdate+this.edgesMaxUpdateRate<e?(this.lastUpdate=e,await this.edges.update()):this.updateTimeout===-1&&(this.updateTimeout=window.setTimeout(()=>{this.update(),this.updateTimeout=-1},this.edgesMaxUpdateRate))});r(this,"hideFills",()=>{this.edges.fillVisible=!1});this.edges=new le(e,s,this.three,o),this.toggleControls(!0),this.edges.setVisible(!0),this.onDraggingEnded.add(this.updateFill),this.onDraggingStarted.add(this.hideFills)}set enabled(e){this._enabled=e,this.world.renderer&&this.world.renderer.setPlane(e,this.three)}get enabled(){return super.enabled}dispose(){super.dispose(),this.edges.dispose()}async setEnabled(e){super.enabled=e,e&&await this.update()}async setVisible(e){super.visible=e,this.toggleControls(e),await this.edges.setVisible(!0)}}class he{constructor(){r(this,"onDisposed",new P);r(this,"enabled",!0);r(this,"_styles",{});r(this,"_defaultLineMaterial",new oe({color:0,linewidth:.001}));r(this,"onAfterUpdate",new P);r(this,"onBeforeUpdate",new P)}get(){return this._styles}update(t){this.onBeforeUpdate.trigger(this._styles),this.onAfterUpdate.trigger(this._styles)}create(t,e,s,i,n,l){if(!s.renderer)throw new Error("The given world doesn't have a renderer!");i||(i=this._defaultLineMaterial);for(const f of e)f.geometry.boundsTree||f.geometry.computeBoundsTree();const o=s.renderer;i.clippingPlanes=o.clippingPlanes;const h={name:t,lineMaterial:i,meshes:e,fillMaterial:n,outlineMaterial:l,fragments:{}};return this._styles[t]=h,h}dispose(){const t=Object.keys(this._styles);for(const e of t)this.deleteStyle(e);this._styles={},this.onDisposed.trigger(),this.onDisposed.reset()}deleteStyle(t,e=!0){var i,n;const s=this._styles[t];s&&(s.meshes.clear(),e&&(s.lineMaterial.dispose(),(i=s.fillMaterial)==null||i.dispose(),(n=s.outlineMaterial)==null||n.dispose())),delete this._styles[t]}}class O extends H{constructor(e){super(e);r(this,"styles");r(this,"fillsNeedUpdate",!1);if(this.components.list.has(O.uuid))throw new Error("You can't use a component and his parent at the same time. Use child only!");this.components.list.set(O.uuid,this),this.PlaneType=ae,this.styles=new he}dispose(){super.dispose(),this.styles.dispose()}async updateEdges(e=!1){if(this.enabled)for(const s of this.list)e||this.fillsNeedUpdate?(await s.updateFill(),this.fillsNeedUpdate=!1):await s.update()}newPlaneInstance(e,s,i){return new this.PlaneType(this.components,e,s,i,this._material,this.styles)}}export{O as E};
