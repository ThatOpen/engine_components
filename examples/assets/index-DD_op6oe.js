var P=Object.defineProperty;var v=(a,r,t)=>r in a?P(a,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[r]=t;var o=(a,r,t)=>(v(a,typeof r!="symbol"?r+"":r,t),t);import{c as C,E as R,M as p,F as g,D as S}from"./graphic-vertex-picker-BY8Y4wOR.js";import{W as k,o as E,f as F,p as D,F as M}from"./index-D_lOu8Cy.js";import{H as u}from"./index-D_xydlFc.js";import{M as O}from"./index-CenXdrKi.js";const h=class h extends C{constructor(t){super(t);o(this,"_world");o(this,"styles",new k);o(this,"outlinePositions",!1);o(this,"_mesh",null);o(this,"onDisposed",new R);o(this,"_meshes",[]);o(this,"_map",{});o(this,"_activeStyles",new Set);o(this,"_styleCallbacks",{});t.add(h.uuid,this),this.setupEvents()}set world(t){if(this._world=t,!t)return;this.getRenderer().postproduction.excludedObjectsPass.addExcludedMaterial(this._points.material)}get world(){return this._world}get _points(){return this._mesh||(this._mesh=new E(new F,new D({size:10,sizeAttenuation:!1,depthTest:!1}))),this._mesh}get enabled(){return!this.world||this.world.isDisposing?!1:this.getRenderer().postproduction.outlinesEnabled}set enabled(t){if(!this.world||this.world.isDisposing)return;const e=this.getRenderer();e.postproduction.outlinesEnabled=t,this.outlinePositions&&(this._points.material.color=this.color,this.world.scene.three.add(this._points))}get color(){return this.getRenderer().postproduction.outlinePass.outlineColor}set color(t){this.getRenderer().postproduction.outlinePass.outlineColor.copy(t),this._points.material.color.copy(t)}get thickness(){return this.getRenderer().postproduction.outlinePass.thickness}set thickness(t){this.getRenderer().postproduction.outlinePass.thickness=t}get fillColor(){return this.getRenderer().postproduction.outlinePass.fillColor}set fillColor(t){this.getRenderer().postproduction.outlinePass.fillColor.copy(t)}get fillOpacity(){return this.getRenderer().postproduction.outlinePass.fillOpacity}set fillOpacity(t){const e=this.getRenderer().postproduction;e.outlinePass.fillOpacity=t}setupEvents(){const t=this.components.get(u);this.styles.guard=e=>t.styles.has(e),this.styles.onItemAdded.add(e=>{const i=this.components.get(u),s=()=>{this._activeStyles.add(e),this.updateFromStyles()},n=()=>{this._activeStyles.delete(e),this.updateFromStyles()};this._styleCallbacks[e]={onHighlight:s,onClear:n},i.events[e].onHighlight.add(s),i.events[e].onClear.add(n)}),this.styles.onBeforeDelete.add(e=>{const{onHighlight:i,onClear:s}=this._styleCallbacks[e];t.events[e].onHighlight.remove(i),t.events[e].onClear.remove(s),this._activeStyles.delete(e),delete this._styleCallbacks[e]}),t.styles.onItemDeleted.add(e=>this.styles.delete(e))}async updateFromStyles(){const t=this.components.get(u),e=[];for(const s of this._activeStyles){const n=t.selection[s];n&&e.push(n)}const i=p.join(e);this._map=i,await this.update()}async update(t=this._map){if(t===this._map&&this.cleanMeshes(),this.outlinePositions&&this.updatePoints(),Object.keys(t).length===0)return;const e=this.components.get(g),s=this.getRenderer().postproduction.outlinePass,d=await this.components.get(O).get(t);for(const c of Object.keys(t)){const l=e.list.get(c),y=new Set(await(l==null?void 0:l.getItemsByVisibility(!1)));if(l){for(const[H,_]of d.entries())for(const[w,b]of _)if(!y.has(w))for(const m of b)this._meshes.push(m),s.scene.add(m)}}}async addItems(t){p.add(this._map,t),await this.update(t)}async removeItems(t){p.remove(this._map,t),await this.update()}clean(){this._map={},this._activeStyles.clear(),this.cleanMeshes(),this._mesh&&this.components.get(S).destroy(this._mesh,!0,!0),this._mesh=null}dispose(){this.styles.clear(),this.clean(),this.onDisposed.trigger(h.uuid)}cleanMeshes(){for(const t of this._meshes)t.removeFromParent();this._meshes=[]}async updatePoints(){let t=0;for(const[s,n]of Object.entries(this._map))t+=n.size;this._points.geometry.setAttribute("position",new M(new Float32Array(t*3),3));const i=await this.components.get(g).getPositions(this._map);for(let s=0;s<i.length;s++){const{x:n,y:d,z:c}=i[s];this._points.geometry.attributes.position.array[s*3]=n,this._points.geometry.attributes.position.array[s*3+1]=d,this._points.geometry.attributes.position.array[s*3+2]=c}this._points.geometry.attributes.position.needsUpdate=!0}getRenderer(){if(!this.world)throw new Error("You must set a world to use the outliner!");const t=this.world.renderer;if(!t.postproduction)throw new Error("The world given to the outliner must use the postproduction renderer.");return t}};o(h,"uuid","2fd3bcc5-b3b6-4ded-9f64-f47a02854a10");let f=h;export{f as O};
