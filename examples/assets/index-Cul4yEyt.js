var C=Object.defineProperty;var D=(v,g,e)=>g in v?C(v,g,{enumerable:!0,configurable:!0,writable:!0,value:e}):v[g]=e;var c=(v,g,e)=>(D(v,typeof g!="symbol"?g+"":g,e),e);import{c as N,E as m,f as O,R as b,M as p,F as I}from"./graphic-vertex-picker-DjytwMNw.js";import{z as T,C as j,Y as x,S as B,i as z}from"./index-b0R13blq.js";const y=class y extends N{constructor(e){super(e);c(this,"onDisposed",new m);c(this,"onBeforeUpdate",new m);c(this,"onAfterUpdate",new m);c(this,"onSetup",new m);c(this,"isSetup",!1);c(this,"enabled",!0);c(this,"events",{});c(this,"multiple","ctrlKey");c(this,"zoomFactor",1.5);c(this,"zoomToSelection",!1);c(this,"backupColor",null);c(this,"selection",{});c(this,"config",{selectName:"select",selectionColor:null,autoHighlightOnClick:!0,world:null,selectEnabled:!0,selectMaterialDefinition:{color:new j("#BCF124"),renderedFaces:T.ONE,opacity:1,transparent:!1}});c(this,"styles",new x);c(this,"autoToggle",new Set);c(this,"mouseDownPosition",{x:0,y:0});c(this,"mouseMoveThreshold",5);c(this,"selectable",{});c(this,"eventManager",new O);c(this,"_mouseState",{down:!1,moved:!1});c(this,"_fromHighlight",!1);c(this,"restorePreviousColors",(e=this.selection.select)=>{for(const[t,s]of Object.entries(this.selection))if(!(t===this.config.selectName||!this.styles.get(t)))for(const[n,r]of Object.entries(e)){const a=s[n];if(!a)continue;const l=[...r].filter(o=>a.has(o));l.length!==0&&new Set(l)}});c(this,"onMouseDown",e=>{this.enabled&&(this.debounceTimeout&&clearTimeout(this.debounceTimeout),this.mouseDownPosition={x:e.clientX,y:e.clientY},this._mouseState.down=!0)});c(this,"debounceTimeout",null);c(this,"onMouseUp",async e=>{if(!this.enabled)return;const{world:t,autoHighlightOnClick:s,selectEnabled:i}=this.config;if(!t)throw new Error("No world found!");if(!t.renderer)throw new Error("This world doesn't have a renderer!");if(e.target===t.renderer.three.domElement){if(this._mouseState.down=!1,this._mouseState.moved||e.button!==0){this._mouseState.moved=!1;return}if(this._mouseState.moved=!1,s&&i){const n=this.multiple==="none"?!0:!e[this.multiple];await this.highlight(this.config.selectName,n,this.zoomToSelection)}}});c(this,"onMouseMove",async e=>{if(!this.enabled)return;const t=e.clientX-this.mouseDownPosition.x,s=e.clientY-this.mouseDownPosition.y,i=Math.sqrt(t*t+s*s);this._mouseState.moved||i>this.mouseMoveThreshold&&(this._mouseState.moved=this._mouseState.down)});this.components.add(y.uuid,this),this.eventManager.list.add(this.onSetup),this.eventManager.list.add(this.onDisposed),this.setStyleEvents()}setStyleEvents(){this.styles.onBeforeDelete.add(async({key:e})=>{if(await this.clear(e),delete this.selection[e],!(e in this.events))return;const{onClear:t,onHighlight:s,onBeforeHighlight:i}=this.events[e];this.eventManager.list.delete(t),this.eventManager.list.delete(s),this.eventManager.list.delete(i),delete this.events[e]}),this.styles.onItemSet.add(({key:e})=>{this.selection[e]={};const t=new m,s=new m,i=new m;this.events[e]={onHighlight:t,onClear:i,onBeforeHighlight:s},this.eventManager.add([i,t,s])})}async dispose(){this.setupEvents(!1),this.onBeforeUpdate.reset(),this.onAfterUpdate.reset(),this.selection={},this.styles.clear(),this.onDisposed.trigger(y.uuid),this.eventManager.reset(),this.isSetup=!1}add(e){if(console.warn("highlighter.add() is deprecated, use highlighter.styles.set() instead"),typeof e=="string")this.styles.set(e,null);else{const{customId:t}=e;this.styles.set(t,e)}}async remove(e){console.warn("highlighter.remove() is deprecated, use highlighter.styles.delete() instead"),this.styles.delete(e)}async highlight(e,t=!0,s=this.zoomToSelection,i=null){if(!this.enabled)return;if(!this.config.world)throw new Error("No world found in config!");const n=this.config.world;if(!this.selection[e])throw new Error(`Selection ${e} does not exist.`);const l=await this.components.get(b).get(n).castRay();if(!l||l.localId===void 0||l.localId===null){t&&this.clear(e);return}let o=l.fragments.modelId;const{localId:h}=l;l.fragments.isDeltaModel&&(o=l.fragments.parentModelId);const d={[o]:new Set([h])};await this.highlightByID(e,d,t,s,i,!0)}async highlightByID(e,t,s=!0,i=this.zoomToSelection,n=null,r=!1){if(!this.enabled)return;this._fromHighlight=!0,this.events[e].onBeforeHighlight.trigger(this.selection[e]),s&&await this.clear(e);let a=p.clone(t);const l=this.components.get(I);for(const[o,h]of Object.entries(t)){const d=l.list.get(o);d!=null&&d.isDeltaModel&&d.parentModelId&&p.add(a,{[d.parentModelId]:h})}if(n){const o=p.clone(n);for(const[h,d]of Object.entries(o)){const f=l.list.get(h);f!=null&&f.deltaModelId&&p.add(o,{[f.deltaModelId]:d})}a=p.intersect([a,n])}if(r&&this.autoToggle.has(e)){const o={};let h=!1;for(const d in a){const f=this.selection[e][d];if(!f)continue;const M=a[d];for(const u of M)if(f.has(u)){f.delete(u);let w=o[d];w||(w=new Set,o[d]=w),w.add(u),h=!0}else f.add(u);a[d]=f}h&&(this.events[e].onClear.trigger(o),e===this.config.selectName&&this.restorePreviousColors(o))}this.updateStyleMap(e,a),this.events[e].onHighlight.trigger(this.selection[e]),this._fromHighlight=!1,await this.updateColors(),i&&await this.zoomSelection(a)}async updateColors(){const e=this.components.get(I),t=[e.resetHighlight()];for(const[s,i]of Object.entries(this.selection)){const n=this.styles.get(s);if(!n)continue;const r=s==="select"||!this.styles.get(this.config.selectName)?i:this.getMapWithoutSelection(s);if(r){for(const[a,l]of Object.entries(r)){const o=e.list.get(a);o!=null&&o.deltaModelId&&p.add(r,{[o.deltaModelId]:l})}t.push(e.highlight({...n,customId:s},r))}}t.push(e.core.update(!0)),await Promise.allSettled(t)}updateStyleMap(e,t){const s=this.selection[e];for(const i in t){let n=s[i];n||(n=new Set,s[i]=n);const r=t[i];for(const a of r)n.add(a)}if(e!==this.config.selectName)for(const[i,n]of Object.entries(this.selection)){if(i===this.config.selectName||i===e)continue;const r=n;for(const[a,l]of Object.entries(s)){const o=r[a];if(o)for(const h of l)o.delete(h)}}}getMapWithoutSelection(e,t){const s=this.selection[e];if(!s)throw new Error(`Style ${e} does not exist.`);const i=this.selection[this.config.selectName]??{},n={};for(const r in s){const a=s[r],l=e===this.config.selectName?new Set:i[r]??new Set,o=Array.from(a).filter(h=>{var d;return!l.has(h)&&(!t||((d=t[r])==null?void 0:d.has(h)))});o.length>0&&(n[r]=new Set(o))}return Object.keys(n).length>0?n:null}async clear(e,t){const s=e?[e]:Object.keys(this.selection),i=t??void 0;for(const n of s){const r=this.selection[n]??{},a=i??r;n===this.config.selectName&&this.restorePreviousColors();const l={};for(const[o,h]of Object.entries(a)){const d=r[o];if(d)for(const f of h){if(!d.delete(f))continue;let u=l[o];u||(u=new Set,l[o]=u),u.add(f)}}Object.keys(l).length>0&&this.events[n].onClear.trigger(l),this.selection[n]={}}this._fromHighlight||await this.updateColors()}setup(e){if(this.isSetup)return;this.config={...this.config,...e};const{selectName:t,selectionColor:s,selectMaterialDefinition:i}=this.config;this.config.world&&this.components.get(b).get(this.config.world),i?(s&&(console.warn("highlighter.config.selectionColor is deprecated, use selectMaterialDefinition instead"),i.color=s),this.styles.set(t,i)):this.styles.set(t,null),this.autoToggle.add(this.config.selectName),this.setupEvents(!0),this.enabled=!0,this.isSetup=!0,this.onSetup.trigger(this)}async zoomSelection(e){if(!this.config.world)throw new Error("No world found in config!");const t=this.config.world;let s=!1;for(const S in e)if(e[S].size>0){s=!0;break}if(!s||!t.camera.hasCameraControls())return;const n=await this.components.get(I).getBBoxes(e),r=new B,a=new z;for(const S of n)a.union(S);a.getBoundingSphere(r);const l=1/0,o=-1/0,{x:h,y:d,z:f}=r.center,M=r.radius===l||h===l||d===l||f===l,u=r.radius===o||h===o||d===o||f===o,w=r.radius===0;if(M||u||w)return;r.radius*=this.zoomFactor,await t.camera.controls.fitToSphere(r,!0)}setupEvents(e){if(!this.config.world){console.log("No world found while setting up events!");return}if(this.config.world.isDisposing)return;if(!this.config.world.renderer)throw new Error("The given world doesn't have a renderer!");const t=this.config.world.renderer.three.domElement;t.removeEventListener("mousedown",this.onMouseDown),t.removeEventListener("mouseup",this.onMouseUp),t.removeEventListener("pointermove",this.onMouseMove),e&&(t.addEventListener("mousedown",this.onMouseDown),t.addEventListener("mouseup",this.onMouseUp),t.addEventListener("pointermove",this.onMouseMove))}};c(y,"uuid","cb8a76f2-654a-4b50-80c6-66fd83cafd77");let E=y;export{E as H};
